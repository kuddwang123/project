### Iot 通信模块梳理

#### 模块边界

```plantuml
@startuml
skin rose
node middleware_node {
    component appDataHandler as appH1
    component business as bus1
    appH1 - bus1
}

node collect_node {
    node appDataRouter as appRouter
    cloud AwsConn {
        component AwsMqtt as awsMqtt
        component AwsShadow as awsShadow
    }
}

node blueTooth {
    component "rosNode" as ros
    component BlueZ as bluez
    bluez - ros
}

appH1 .> appRouter : ros topic
appRouter -> awsMqtt : aws SDK
appRouter --> awsShadow : aws SDK
appRouter ..> ros : ros topic
@enduml
```

#### 通信模型
```plantuml
@startuml
skin rose
actor User as user
participant App as app
entity BlueTooth as blue
control AwsMqtt as mqtt
database AwsShadow as shadow
participant Device as device

== Bluetooth in use ==
user -> app : request
app -> blue
blue -> device

device --> blue
blue --> app
app --> user : response
hnote across:
device -> blue
blue -> app
app -> user : report

== Aws in use ==
group shadow
device -> shadow :value report
shadow -> shadow :update doc
user -> app :get value
app -> shadow : get shadow 
note right
    App get value from shadow doc,
    which is previously updated by device
end note

hnote across:
user -> app: set value
app -> shadow : update shadow
shadow -> device: update event\n **change value**
device -> shadow: real value report
shadow -> app : shadow report
note right
    App set value to modify 'desire' in shadow doc,
    then device receive the update event with topic 'delta'.
    Device set value according to appdata, and the report to
    modity shadow doc, which is the source of App data display. 
end note
app -> user : data display

end group

== Mqtt topic in use ==
group mqtt
user -> app : set value
app -> mqtt : topic pub
mqtt -> device : topic pub
device -> device : topic sub, \nchange value
device --> mqtt : topic pub, report response
mqtt --> app : topic pub
app --> app : topic sub
app --> user : response
end group
note right
    When to report data via mqtt topic?
end note
@enduml
```

#### 通信接口
##### ros接口
| topic/service    | ros service/msg |  type    |paraphrase | data direction 
|------------------|-------|---------|-----------|---------------------------
| /IotGetShadow    | IotShadow |Service|  Get Aws shadow document| device->aws
| /IotDeleteShadow | IotShadow|Service|  Delete Aws shadow document | device->aws
| /IotUpdateShadow | IotShadow |Service|  Update Aws shadow document reliably | devide->aws
| /ReqFromApp      | AppMsg |Topic    | Data request from APP | aws->device, bt->device
| /RespToApp       | AppMsg|Topic    | Data response for APP | device->aws, device->bt
| /ReportApp       | AppMsg|Topic    | Device daata report to APP | device->aws, device->bt

##### ros消息/服务
* service: IotShadow

getShadowDoc

```plantuml
@startjson
{
   "req":"",
   "res":{
    "desired(AppData[])":"Shadow doc desired json string",
    "metadata(AppData[])":"Shadow doc meta json string",
    "timestamp(uint64)":"The Epoch date and time, the response was generated by AWS IoT",
    "iotret":{
        "code(int64)":"Response code",
        "msg(string)":"Response message"
      }
   }
}
@endjson
```


deleteShadowDoc
```plantuml
@startjson
{
    "req":"",
    "res":{
        "timestamp(uint64)":"The time the response was generated by AWS IoT",
        "iotret":{
            "code(int64)":"Response code",
            "msg(string)":"Response message"
        }
    }
}
@endjson
```

updateShadow
```plantuml
@startjson
{
    "req":{
        "appdata(AppData[])":"Data to update shadow document"
    },
    "res":{
        "timestamp(uint64)":"The time the response was generated by AWS IoT",
        "iotret":{
            "code(int64)":"Response code",
            "msg(string)":"Response message"
        }
    }
}
@endjson
```

* AppData
```plantuml
@startjson
{
    "key(string)":"App data key",
    "payload(string)":"App data payload",
    "res(uint8)":"res code, only necessary for a response"
}
@endjson
```

* AppMsg
```plantuml
@startjson
{
    "appdata(AppData[])":"App data array",
    "metadata(AppData[])":"Shadow App meta data array",
    "timestamp(uint64)":"Shadow doc timestamp",
    "from(uint8)":"Which link the message from, need write back to the response(1, bt; 2, shadow; 3, mqtt topic)",
    "to(uint8)":"To which link the message should report(1, shadow; 2, mqtt topic)"
}
@endjson
```

#### 类图
```plantuml
@startuml
skin rose
class AppCommunication {
    ..hj function class..
}

class AppDataRouter {
    ..Handle data transport between device and App..
    +initialize()
    +initIot()
    +runIot()
}

class IotShadowClientLink {
    ..Handle shadow event lifetime and wrap shadow client.. 
    +initialize()
    +dvcUpdateShadow()
    +linkGetShadow()
    +linkGetShadow()
    +linkDeleteShadow()
    +linkIotUpdateShadow()
}

class IotShadowClient {
    ..Aws shadow client SDK package..
    +connectSlot()
    +pubGetShadowDoc()
    +setGetShadowAccCb()
    +setGetShadowRejCb()
    +pubDelShadowDoc()
    +setDelShadowAccCb()
    +setDelShadowRejCb()
    +pubUpdateShadowDoc()
    +setUpdateShadowAccCb()
    +setUpdateShadowRejCb()
    +setUpdateDeltaCb()
}

class IotMqttClientLink {
    ..Handle mqtt event lifetime and wrap mqtt client..
    +initialize()
    +iotMqttResp()
    +iotMqttReport()
}

class IotMqttClient {
    ..Aws mqtt client SDK package..
    +connectSlot()
    +mqttReport()
    +mqttResp()
    +setAppMqttReqCb()
}

class AwsConnectionManager {
    ..Aws connection SDK package..
    +initialize()
    +getAwsConnection()
    +setEndPoint()
    + isIotConnected()
    + disconnect()
    + startConnect()
    + startReconnect()
    + addConnListener()
    + addDropListener()
}

AppDataRouter *--> AppCommunication
IotShadowClientLink *--> AppDataRouter
IotMqttClientLink *--> AppDataRouter
AwsConnectionManager o--> AppDataRouter
IotShadowClient o--> IotShadowClientLink
IotMqttClient o--> IotMqttClientLink
IotShadowClient ..> AwsConnectionManager
IotMqttClient ..> AwsConnectionManager
@enduml
```
* AppCommunication: 作为Function Iot的启动入口类，负责初始化Iot核心模块，同时负责解析middleware_node传来的appdata，进行Iot连接相关工作。
* AppDataRouter: 负责设备和App端的数据传递，承接ros接口和iot通讯接口之间的调用，主要职责是分发传递不同链路来的app数据。初始化时构建aws和蓝牙连接。
* AwsConnectionManager: Aws连接管理，单例类，提供aws连接的全局访问点。主要职责是完成和Amazon云连接的底层sdk调用，对外提供操作aws连接的相关接口。
* IotShadowClientLink: 对应用层提供操作aws shadow doc方法，同时对应用层请求的shadow服务事件进行管理。
* IotShadowClient: 与aws connection进行shadow相关的话题订阅,向IotShadowClientLink提供shadow相关事件的回调注册和操作shadow doc接口，是对底层aws sdk的封装。
* IotMqttClientLink: 对应用层提供基于mqtt topic的响应和上报方法，同时对来自mqtt topic的请求的和应用层的响应进行一一对应。
* IotMqttClient: 与aws connection进行mqtt自定义topic相关的话题订阅,向IotMqttClientLink提供来自App请求事件的回调注册和回复、上报App的方法，是对底层aws sdk的封装。

#### 线程模型
* iot连接
```plantuml
@startuml
skin rose
actor user as user
participant "collect_node thread" as main
boundary "aws connection" as aws_conn
participant "awsconnection thread" as aws_conn_thread
boundary "client link" as client
participant "subscribe thread" as sub

user->main : key,cert,endpoint,thingName
main -> aws_conn:start connect
aws_conn -> aws_conn_thread: thread generate
group loop
    aws_conn_thread -> aws_conn_thread : connect
end group
aws_conn_thread -> client :singal2
client -> sub : thread generate
group loop
sub -> sub : subscribe to AWS
end loop

note right
    result return?
end note
@enduml
```

* iot通讯
```plantuml
@startuml
skin rose
participant "ros thread" as ros
participant "collect_node thread" as main
entity "request queue" as request
boundary aws as aws
participant "aws loop thread" as awscb

group ros service for shadow
ros -> main : service request
main -> request : push to request queue
main -> aws : aws topic publish
main -> main : condition wait（timeout）
awscb --> main : condition notify
main --> ros : service response
end group

group ros topic for mqtt req&res
awscb -> aws : app data income
aws -> request: push to request queue
aws -> main : form ros msg
main -> ros :ros topic publish

ros -> main : ros topic publish
main -> request : get request event
request --> main :return event
main -> aws :aws topic publish
end group
@enduml
```

#### TODO
* 蓝牙模块接入
* 输出连接状态上报接口
* 长时间不用app，不上报实时数据(mqtt topic)